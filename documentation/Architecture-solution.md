# Исследование архитектурного решения
## Проектирование архитектуры

---
### 1.1 Определение типа приложения 
  Выбор соответствующего типа приложения – ключевой момент процесса проектирования приложения. Этот выбор определяется конкретными требованиями и ограничениями среды. Также от многих приложений требуется поддержка множества типов клиентов. 
Приложение "HeartHunter" разработанное командой "Heart Worms inc." является 
**приложением для мобильных устройств**. Данное приложение доступно только на мобильных устройствах с системой Android.

### 1.2 Выбор стратегии развертывания 

При проектировании приложения была выбрана стратегия **нераспределенного развертывания**. Данный выбор был осуществлен по нескольким причинам:  
1) Простая реализация,  
2) Отсутствие необходимости в масштабировании приложения,  
3) Вся функциональность и слои приложения, кроме функциональности хранения данных, располагаются на одном сервере.

![Структурная схема приложения на основе функциональных блоков](https://github.com/helistam/HeartHunter/blob/main/documentation/files/unallocated_deployment.png)

### 1.3 Обоснование выбора технологий 
1.Язык написания приложения: 
 
&#187; <kbd>Kotlin</kbd>  - статически типизированный,объектно-ориентированный язык программирования, работающий поверх Java Virtual Machine. Данная технология идеально подхрдит для разработки мобильных приложений. 

2.Фреймворки:  
&#187; <kbd>Jetpack Compose</kbd> - выпущенный в 2020 году фреймворк, для разработки GUI на замену XML-файлов. Он сильно упрощает создание анимации с состояниями, значения которых можно легко менять в среде выполнения. Кроме того, навигация с Jetpack Compose становится намного удобнее, поскольку установка всех правил внутри XML-файлов сопровождалась чрезвычайными сложностями.  
&#187; <kbd>Spring</kbd> - Фреймворк нужен, чтобы разработчикам было легче проектировать и создавать приложения. Spring не связан с конкретной парадигмой или моделью программирования, поэтому его могут использовать как каркас для разных видов приложений.  

3.База данных  
&#187; <kbd>MySql</kbd> - Данная реляционная база данных была выбрана в связи с тем, что в нашем приложении клиенты в основном будут только запрашивать данные с сервера, а не обновлять их на сервере(тогда бы подошла PostgreSQL). Для выполнения запросов на чтение из базы данных MySQL показывает более высокую производительность.

### 1.4 Показатели качества

 &#187; Удобство и простота обслуживания/Возможность повторного использования.  
 Каждый элемент приложения является самостоятельной функцией и может легко изменяться или использоваться повторно.  
 &#187; Тестируемость.  
 По мере разработки кода были проведены множественные тесты, для проверки работоспособности кода.  
 &#187; Безопасность  
 Для защиты пользовательских данных в приложении была введена регистрация.  
 &#187; Надежность 
 Система способна поддерживать работоспособность в течении длительного времени.  
 &#187;Удобство и простота использования. 
 Данное приложение разработано так, чтобы обеспечить максимальную простоту использования.При проектировании учитывались наиболее часто используемые пользователем функции и размещались они в зонах, удобных для пользователя.

### 1.5 Пути реализации сквозной функциональности 
  
В приложении присутствуют несколько путей реализации сковозной функциональности:

&#187; Аутентификация: Система распознает пользователя по его учетным данным и предоставляет и в успешном случае предотавлет доступ к системе.  
&#187; Авторизация: На основе роли пользователя система предоставляет пользователю доступ к тем или иным ресурсам приложения.  
&#187; Управление исключениями: Все исключительные ситуации приложения обрабатываются централизовано и отлавливаются по всему приложению глобально.

### 1.6 Структурная схема приложения на основе функциональных блоков

![Структурная схема приложения на основе функциональных блоков](https://github.com/helistam/HeartHunter/blob/main/documentation/files/schema.png)


### 2.1 Архитектура As Is
  
![Диаграмма классов](https://github.com/helistam/HeartHunter/blob/main/diagrams/images/ClassDiagram.png)
  
### 3.1 Сравнение архитектур   

&#187; Архитектура "To be" – это финальный результат, к которому мы стремимся в рамках данного проекта. Она представлена в виде крупных абстрактных блоков, давая общее представление о будущей системе.  

&#187; Архитектура "As is" – это текущее состояние функциональности приложения на данном этапе разработки. Она имеет более детальный вид и фокусируется на определенной небольшой части проекта. Детализация доходит до уровня классов и сигнатур их методов.  
  
### Пути улучшения:  
  
&#187; SOLID:  
    - Single responsibility principle (SRP): Каждый класс должен иметь только одну причину для изменения.  
    - Open-closed principle (OCP): Классы должны быть открытыми для расширения, но закрытыми для изменения.  
    - Liskov substitution principle (LSP): Подклассы должны быть взаимозаменяемы со своими суперклассами.  
    - Interface segregation principle (ISP): Интерфейсы должны быть максимально лаконичными и содержать только те методы, которые логически связаны между собой.  
    - Dependency inversion principle (DIP): Зависимости должны инвертироваться, чтобы высокоуровневые модули не зависели от низкоуровневых.  
&#187; Модульность: Разделение системы на независимые модули, которые слабо связаны между собой.  
&#187; Инкапсуляция: Скрытие деталей реализации модулей от других модулей.  
&#187; Интерфейсы: Определение четких интерфейсов для взаимодействия между модулями.  
  
Архитектурные стили:  
&#187; MVC: Model-View-Controller. Разделение системы на три компонента: модель, представление и контроллер.  
&#187; SOA: Service-Oriented Architecture. Разделение системы на автономные сервисы, которые взаимодействуют между собой через веб-сервисы.  
&#187; Microservices: Микросервисная архитектура. Разделение системы на множество небольших, независимых сервисов.  
  
Архитектурные шаблоны:  
&#187; Фабрика: Создание объектов без необходимости указывать конкретный класс.  
&#187; Стратегия: Определение семейства алгоритмов, инкапсуляция каждого из них и возможность их взаимозамены.  
&#187; Singleton: Обеспечение того, чтобы класс имел только один экземпляр.  
  
Приемы проектирования:    
&#187; Инверсия зависимостей: Внедрение зависимостей в модули через инъекцию.  
&#187; Тестирование: Написание тестов для проверки корректности работы модулей.  
&#187; Документирование: Описание архитектуры системы и ее компонентов.  
